[
  {
    "id": 1762681043,
    "title": "Suggest me some ideas of automation project in Python",
    "summary": "A Python script that fetches current weather from OpenWeatherMap, displays it in a Tkinter GUI (optionally suitable for a mirror display), and sends a daily notification via email (or a text/message service) at a specified morning time. The dashboard updates hourly and the notification logic uses the schedule library.",
    "details_markdown": "import requests\nimport tkinter as tk\nimport schedule\nimport time\nimport datetime\nimport smtplib\nimport ssl\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.image import MIMEImage\nfrom threading import Thread\n\n# ==================== Configuration ====================\nAPI_KEY = \"YOUR_OPENWEATHERMAP_API_KEY\"\nCITY_NAME = \"New York\"\nUPDATE_INTERVAL = 60 * 60  # in seconds (1 hour)\nNOTIFICATION_HOUR = 6  # 6 AM\nNOTIFICATION_MINUTE = 0\n# Email configuration\nSMTP_SERVER = \"smtp.gmail.com\"\nSMTP_PORT = 587\nSENDER_EMAIL = \"youremail@gmail.com\"\nSENDER_PASSWORD = \"app_specific_password_or_oauth\"\nRECIPIENT_EMAIL = \"recipient@example.com\"\n\n# ==================== Weather Fetching ====================\n\ndef fetch_weather():\n    \"\"\"Fetch current weather data from OpenWeatherMap.\"\"\"\n    url = f\"https://api.openweathermap.org/data/2.5/weather?q={CITY_NAME}&appid={API_KEY}&units=metric\"\n    response = requests.get(url)\n    response.raise_for_status()\n    data = response.json()\n    weather = {\n        \"temp\": data[\"main\"][\"temp\"],\n        \"description\": data[\"weather\"][0][\"description\"],\n        \"icon\": data[\"weather\"][0][\"icon\"],\n    }\n    return weather\n\n# ==================== GUI Dashboard ====================\n\ndef create_dashboard():\n    \"\"\"Create and return the Tkinter GUI components.\"\"\"\n    root = tk.Tk()\n    root.title(\"Weather Dashboard\")\n    root.geometry(\"300x200\")\n    root.configure(bg=\"black\")\n\n    city_label = tk.Label(root, text=CITY_NAME, font=(\"Helvetica\", 16), fg=\"white\", bg=\"black\")\n    city_label.pack(pady=5)\n\n    temp_label = tk.Label(root, font=(\"Helvetica\", 20), fg=\"yellow\", bg=\"black\")\n    temp_label.pack(pady=5)\n\n    desc_label = tk.Label(root, font=(\"Helvetica\", 14), fg=\"lightgray\", bg=\"black\")\n    desc_label.pack(pady=5)\n\n    icon_label = tk.Label(root, bg=\"black\")\n    icon_label.pack(pady=5)\n\n    # Store references for updating\n    root.widgets = {\n        \"temp_label\": temp_label,\n        \"desc_label\": desc_label,\n        \"icon_label\": icon_label,\n    }\n\n    return root\n\n# ==================== Dashboard Update ====================\n\ndef update_dashboard(root):\n    \"\"\"Fetch weather and update GUI labels.\"\"\"\n    try:\n        weather = fetch_weather()\n        root.widgets[\"temp_label\"].config(text=f\"{weather['temp']:.1f} °C\")\n        root.widgets[\"desc_label\"].config(text=weather['description'].title())\n\n        # Load icon image\n        icon_url = f\"https://openweathermap.org/img/wn/{weather['icon']}@2x.png\"\n        icon_response = requests.get(icon_url)\n        icon_response.raise_for_status()\n        image_data = icon_response.content\n        image = tk.PhotoImage(data=image_data)\n        root.widgets[\"icon_label\"].config(image=image)\n        root.widgets[\"icon_label\"].image = image  # keep reference\n\n    except Exception as e:\n        root.widgets[\"temp_label\"].config(text=\"Error updating\")\n        print(\"Error in update_dashboard:\", e)\n\n    # Reschedule next update\n    root.after(UPDATE_INTERVAL * 1000, update_dashboard, root)\n\n# ==================== Notification ====================\n\ndef send_notification():\n    \"\"\"Send hourly weather summary via email at the scheduled time.\"\"\"\n    try:\n        weather = fetch_weather()\n        subject = f\"Weather Update for {CITY_NAME} – {datetime.datetime.now().strftime('%Y-%m-%d')}\"\n        body = f\"Current temperature: {weather['temp']:.1f} °C\\nCondition: {weather['description'].title()}\"\n\n        msg = MIMEMultipart()\n        msg[\"From\"] = SENDER_EMAIL\n        msg[\"To\"] = RECIPIENT_EMAIL\n        msg[\"Subject\"] = subject\n        msg.attach(MIMEText(body, \"plain\"))\n\n        context = ssl.create_default_context()\n        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:\n            server.starttls(context=context)\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Notification sent at\", datetime.datetime.now().strftime('%H:%M:%S'))\n    except Exception as e:\n        print(\"Failed to send notification:\", e)\n\n# ==================== Scheduler Thread ====================\n\ndef run_schedule():\n    \"\"\"Run the schedule loop in a separate thread.\"\"\"\n    while True:\n        schedule.run_pending()\n        time.sleep(1)\n\n# ==================== Main ====================\n\nif __name__ == \"__main__\":\n    # Schedule daily notification\n    schedule.every().day.at(f\"{NOTIFICATION_HOUR:02d}:{NOTIFICATION_MINUTE:02d}\").do(send_notification)\n\n    dashboard = create_dashboard()\n    # Initial update\n    update_dashboard(dashboard)\n\n    # Start scheduler thread\n    scheduler_thread = Thread(target=run_schedule, daemon=True)\n    scheduler_thread.start()\n\n    # Run Tkinter event loop\n    dashboard.mainloop()\n",
    "status": "success",
    "executed_at": "2025-11-09T09:37:23.031481Z",
    "source": "https://www.reddit.com/r/learnpython/comments/13l1ru4/suggest_me_some_ideas_of_automation_project_in/"
  },
  {
    "id": 1762680862,
    "title": "9 Python Projects That Look Hard (But Are Surprisingly ...",
    "summary": "",
    "details_markdown": "",
    "status": "error",
    "executed_at": "2025-11-09T09:34:22.493264Z",
    "source": "https://python.plainenglish.io/9-python-projects-that-look-hard-but-are-surprisingly-easy-to-build-611bb1c836ac?source=rss----78073def27b8---4"
  },
  {
    "id": 1762679284,
    "title": "9 Python Projects That Look Hard (But Are Surprisingly ...",
    "summary": "Provides a modular Python script that can (1) clean a specified directory by removing duplicate or temporary files, (2) organize screenshots by timestamp into subfolders, and (3) summarize emails fetched via IMAP and save a concise summary to a text file. Each feature can be executed independently via command line arguments.",
    "details_markdown": "import argparse\\nimport hashlib\\nimport os\\nimport shutil\\nimport datetime\\nimport imaplib\\nimport email\\nimport textwrap\\n\\n# ---------- Helper Functions ----------\\n\\n\\ndef get_file_hash(file_path, chunk_size=4096):\\n    \"\"\"Return SHA-256 hash for the given file.\"\"\"\\n    sha = hashlib.sha256()\\n    with open(file_path, 'rb') as f:\\n        for chunk in iter(lambda: f.read(chunk_size), b''):\\n            sha.update(chunk)\\n    return sha.hexdigest()\\n\\n\\ndef clean_directory(target_dir):\\n    \"\"\"Remove duplicate files and temporary files in target_dir.\"\"\"\\n    if not os.path.isdir(target_dir):\\n        raise FileNotFoundError(f\"Directory not found: {target_dir}\")\\n    hashes = {}\\n    removed_duplicates = 0\\n    removed_temps = 0\\n    for root, _, files in os.walk(target_dir):\\n        for name in files:\\n            path = os.path.join(root, name)\\n            # Remove temp files\\n            if name.lower().endswith(('.tmp', '.part')):\\n                os.remove(path)\\n                removed_temps += 1\\n                continue\\n            h = get_file_hash(path)\\n            if h in hashes:\\n                os.remove(path)\\n                removed_duplicates += 1\\n            else:\\n                hashes[h] = path\\n    return removed_duplicates, removed_temps\\n\\n\\ndef organize_screenshots(src_dir, dest_root):\\n    \"\"\"Move screenshot files into date-based subfolders under dest_root.\"\"\"\\n    screenshots = []\\n    for root, _, files in os.walk(src_dir):\\n        for name in files:\\n            if name.lower().endswith(('.png', '.jpg', '.jpeg')):\\n                screenshots.append(os.path.join(root, name))\\n    for file_path in screenshots:\\n        mtime = os.path.getmtime(file_path)\\n        date_str = datetime.datetime.fromtimestamp(mtime).strftime('%Y-%m-%d')\\n        dest_dir = os.path.join(dest_root, date_str)\\n        os.makedirs(dest_dir, exist_ok=True)\\n        shutil.move(file_path, os.path.join(dest_dir, os.path.basename(file_path)))\\n    return len(screenshots)\\n\\n\\ndef summarize_email(imap_server, username, password, mailbox='INBOX'):\\n    \"\"\"Fetch unread emails and write a short summary for each.\"\"\"\\n    mail = imaplib.IMAP4_SSL(imap_server)\\n    mail.login(username, password)\\n    mail.select(mailbox)\\n    typ, data = mail.search(None, 'UNSEEN')\\n    if typ != 'OK':\\n        return 0\\n    messages = data[0].split()\\n    summaries = 0\\n    for num in messages:\\n        typ, msg_data = mail.fetch(num, '(RFC822)')\\n        if typ != 'OK':\\n            continue\\n        raw_email = msg_data[0][1]\\n        msg = email.message_from_bytes(raw_email)\\n        subject = msg.get('Subject', '(No Subject)')\\n        # Extract plain text body\\n        body = ''\\n        if msg.is_multipart():\\n            for part in msg.walk():\\n                if part.get_content_type() == 'text/plain':\\n                    body = part.get_payload(decode=True).decode(errors='ignore')\\n                    break\\n        else:\\n            body = msg.get_payload(decode=True).decode(errors='ignore')\\n        # Very simple summary: first sentence + length hint\\n        first_sentence = body.splitlines()[0] if body.splitlines() else 'No content.'\\n        summary = f\"Subject: {subject}\\nTimestamp: {datetime.datetime.now()}\\nFirst line: {first_sentence}\\nLength: {len(body.split())} words\\n---\\n\"\\n        with open(f'summary_{num.decode()}.txt', 'w', encoding='utf-8') as f:\\n            f.write(summary)\\n        summaries += 1\\n    mail.logout()\\n    return summaries\\n\\n# ---------- Argument Parsing ----------\\n\\nparser = argparse.ArgumentParser(description='Utility for cleaning folders, organizing screenshots, and summarizing emails.')\\nsubparsers = parser.add_subparsers(dest='command', required=True)\\n\\n# Clean command\\nclean_parser = subparsers.add_parser('clean', help='Clean a directory of duplicates and temp files')\\nclean_parser.add_argument('path', help='Target directory to clean')\\n\\n# Organize command\\norg_parser = subparsers.add_parser('organize', help='Organize screenshots into date folders')\\norg_parser.add_argument('src', help='Source directory containing screenshots')\\norg_parser.add_argument('dest', help='Destination root directory for organized screenshots')\\n\\n# Summarize command\\nsum_parser = subparsers.add_parser('summarize', help='Summarize unread emails from an IMAP account')\\nsum_parser.add_argument('server', help='IMAP server address')\\nsum_parser.add_argument('user', help='Username')\\nsum_parser.add_argument('pass', help='Password')\\n\\nargs = parser.parse_args()\\n\\n# ---------- Main Execution ----------\\nif __name__ == '__main__':\\n    if args.command == 'clean':\\n        dupe, temp = clean_directory(args.path)\\n        print(f'Cleaned {args.path}: removed {dupe} duplicates and {temp} temp files.')\\n    elif args.command == 'organize':\\n        moved = organize_screenshots(args.src, args.dest)\\n        print(f'Moved {moved} screenshot(s) from {args.src} to {args.dest}.')\\n    elif args.command == 'summarize':\\n        count = summarize_email(args.server, args.user, args.pass)\\n        print(f'Summarized {count} unread email(s).')\\n",
    "status": "success",
    "executed_at": "2025-11-09T09:08:04.939812Z",
    "source": "https://python.plainenglish.io/9-python-projects-that-look-hard-but-are-surprisingly-easy-to-build-611bb1c836ac?source=rss----78073def27b8---4"
  },
  {
    "id": 1762679259,
    "title": "9 Python Projects That Look Hard (But Are Surprisingly ...",
    "summary": "A small Python toolbox with three ‘smart’ utilities: a folder cleaner that archives old files, a screenshot organizer that moves images into dated folders, and a basic email summarizer that extracts the first sentence of the body. The script can be invoked from the command line with subcommands ‘cleaner’, ‘organize’ and ‘summarize’.",
    "details_markdown": "import os\nimport shutil\nimport datetime\nfrom email import message_from_string\n\n\ndef smart_folder_cleaner(folder_path, cutoff_days, archive_path):\n    \"\"\"Move files older than cutoff_days from folder_path to archive_path.\"\"\"\n    if not os.path.isdir(folder_path):\n        raise ValueError(f\"{folder_path} is not a directory\")\n    if not os.path.exists(archive_path):\n        os.makedirs(archive_path)\n    cutoff = datetime.datetime.now() - datetime.timedelta(days=cutoff_days)\n    for root, dirs, files in os.walk(folder_path):\n        for f in files:\n            filepath = os.path.join(root, f)\n            mtime = datetime.datetime.fromtimestamp(os.path.getmtime(filepath))\n            if mtime < cutoff:\n                rel_path = os.path.relpath(root, folder_path)\n                dest_dir = os.path.join(archive_path, rel_path)\n                os.makedirs(dest_dir, exist_ok=True)\n                shutil.move(filepath, os.path.join(dest_dir, f))\n\n\ndef auto_screenshot_organizer(screenshot_dir, output_dir):\n    \"\"\"Organize screenshots by date into folders inside output_dir.\n    Assumes screenshot filenames contain dates like 'Screenshot 2023-10-12 13-45-00.png'.\"\"\"\n    if not os.path.isdir(screenshot_dir):\n        raise ValueError(f\"{screenshot_dir} is not a directory\")\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    for f in os.listdir(screenshot_dir):\n        if not f.lower().endswith(('.png', '.jpg', '.jpeg')):\n            continue\n        parts = f.split(' ')\n        date_part = None\n        for part in parts:\n            try:\n                datetime.datetime.strptime(part, '%Y-%m-%d')\n                date_part = part\n                break\n            except ValueError:\n                continue\n        if not date_part:\n            date_part = 'unknown_date'\n        dest_dir = os.path.join(output_dir, date_part)\n        os.makedirs(dest_dir, exist_ok=True)\n        shutil.move(os.path.join(screenshot_dir, f), os.path.join(dest_dir, f))\n\n\ndef email_summarizer(raw_email):\n    \"\"\"Very naive summary: return first sentence of the email body.\"\"\"\n    msg = message_from_string(raw_email)\n    body = \"\"\n    if msg.is_multipart():\n        for part in msg.walk():\n            if part.get_content_type() == 'text/plain':\n                charset = part.get_content_charset('utf-8')\n                body = part.get_payload(decode=True).decode(charset, errors='replace')\n                break\n    else:\n        charset = msg.get_content_charset('utf-8')\n        body = msg.get_payload(decode=True).decode(charset, errors='replace')\n    first_sentence = body.split('. ')[0]\n    return first_sentence\n\n\ndef main():\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Simple Python toolbox.\")\n    subparsers = parser.add_subparsers(dest='command')\n\n    sp_cleaner = subparsers.add_parser('cleaner')\n    sp_cleaner.add_argument('folder', help='Folder to clean')\n    sp_cleaner.add_argument('cutoff', type=int, help='Days to keep')\n    sp_cleaner.add_argument('archive', help='Archive folder')\n\n    sp_screenshot = subparsers.add_parser('organize')\n    sp_screenshot.add_argument('screenshot_dir', help='Dir with screenshots')\n    sp_screenshot.add_argument('output_dir', help='Target organized dir')\n\n    sp_email = subparsers.add_parser('summarize')\n    sp_email.add_argument('raw_email_file', help='File containing raw email')\n\n    args = parser.parse_args()\n    if args.command == 'cleaner':\n        smart_folder_cleaner(args.folder, args.cutoff, args.archive)\n        print(f\"Cleaned {args.folder} into {args.archive}\")\n    elif args.command == 'organize':\n        auto_screenshot_organizer(args.screenshot_dir, args.output_dir)\n        print(f\"Organized screenshots from {args.screenshot_dir} into {args.output_dir}\")\n    elif args.command == 'summarize':\n        with open(args.raw_email_file, 'r', encoding='utf-8') as f:\n            raw = f.read()\n        print(\"Summary:\", email_summarizer(raw))\n    else:\n        parser.print_help()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "status": "success",
    "executed_at": "2025-11-09T09:07:39.985346Z",
    "source": "https://python.plainenglish.io/9-python-projects-that-look-hard-but-are-surprisingly-easy-to-build-611bb1c836ac?source=rss----78073def27b8---4"
  },
  {
    "id": 1762436687,
    "title": "9 Python Project Ideas That Instantly Level Up Your Portfolio",
    "summary": "A Python script that automatically categorizes and moves files in a specified directory into subfolders based on their file extensions, demonstrating the 'Smart File Sorter' project idea.",
    "details_markdown": "import os\nimport shutil\nfrom pathlib import Path\n\n\ndef sort_files(target_dir: str):\n    \"\"\"Sort files in target_dir into subfolders based on file extension.\n\n    Parameters\n    ----------\n    target_dir: str\n        Path to directory to organize.\n    \"\"\"\n    root = Path(target_dir).resolve()\n    if not root.is_dir():\n        raise ValueError(f\"Provided path {root} is not a directory.\")\n\n    sort_counts = {}\n\n    for item in root.iterdir():\n        if item.is_file():\n            ext = item.suffix.lower().lstrip('.')\n            if not ext:\n                ext = \"no_extension\"\n            dest_dir = root / ext\n            dest_dir.mkdir(exist_ok=True)\n            dest_path = dest_dir / item.name\n            shutil.move(str(item), str(dest_path))\n            sort_counts[ext] = sort_counts.get(ext, 0) + 1\n\n    print(\"Sorting complete:\\n\")\n    for folder, count in sort_counts.items():\n        print(f\"  {folder}/ : {count} file(s)\")\n\n\nif __name__ == \"__main__\":\n    import sys\n    if len(sys.argv) > 1:\n        target = sys.argv[1]\n    else:\n        target = os.getcwd()\n    try:\n        sort_files(target)\n    except Exception as e:\n        print(f\"Error: {e}\")",
    "status": "success",
    "executed_at": "2025-11-06T13:44:47.899677Z",
    "source": "https://python.plainenglish.io/9-python-project-ideas-that-instantly-level-up-your-portfolio-c1b83126bfc1?source=rss----78073def27b8---4"
  },
  {
    "id": 1762436527,
    "title": "Suggest me some ideas of automation project in Python",
    "summary": "The solution is a single Python script that fetches weather data from OpenWeatherMap, stores it in memory, serves it via a Dash/Flask dashboard, and sends an email or SMS notification every morning with the hourly forecast. It uses APScheduler to schedule hourly fetches and a daily morning notification. The script is designed to run continuously on a device (e.g., Raspberry Pi) that could be mounted on a smart mirror.",
    "details_markdown": "# weather_dashboard.py\nimport os\\nimport json\\nimport csv\\nimport datetime\\nfrom pathlib import Path\\nimport requests\\nfrom dotenv import load_dotenv\\nfrom flask import Flask, jsonify\\nimport dash\\nimport dash_core_components as dcc\\nimport dash_html_components as html\\nimport plotly.graph_objs as go\\nfrom apscheduler.schedulers.background import BackgroundScheduler\\nimport pytz\\nimport smtplib\\nfrom email.mime.text import MIMEText\\nfrom twilio.rest import Client as TwilioClient\\n\\n# ------------------- Configuration -------------------\\nload_dotenv()\\nOWM_API_KEY = os.getenv(\"OWM_API_KEY\")\\nOWM_CITY_ID = os.getenv(\"OWM_CITY_ID\")  # e.g., \"2172797\" for Cairns\\nOWM_UNITS = \"metric\"  # or \"imperial\"\\n\\nSMTP_SERVER = os.getenv(\"SMTP_SERVER\")\\nSMTP_PORT = int(os.getenv(\"SMTP_PORT\", 587))\\nSMTP_USER = os.getenv(\"SMTP_USER\")\\nSMTP_PASSWORD = os.getenv(\"SMTP_PASSWORD\")\\nEMAIL_FROM = os.getenv(\"EMAIL_FROM\")\\nEMAIL_TO = os.getenv(\"EMAIL_TO\")\\n\\nTWILIO_SID = os.getenv(\"TWILIO_SID\")\\nTWILIO_TOKEN = os.getenv(\"TWILIO_TOKEN\")\\nTWILIO_FROM = os.getenv(\"TWILIO_FROM\")\\nTWILIO_TO = os.getenv(\"TWILIO_TO\")\\n\\nMIRROR_URL = os.getenv(\"MIRROR_URL\", \"http://localhost:8050\")\\n\\n# Scheduler timezone and daily notification time\nTIMEZONE = os.getenv(\"TIMEZONE\", \"UTC\")\\nNOTIFY_HOUR = int(os.getenv(\"NOTIFY_HOUR\", 7))  # 07:00 local time\\n\\n# ------------------- Global State -------------------\\nweather_data = []  # List of dicts with keys: dt, temp, weather\\n\\n# ------------------- Utility Functions -------------------\\ndef fetch_weather_data():\\n    \"\"\"Fetch hourly forecast from OpenWeatherMap and store in weather_data.\"\"\"\\n    url = f\"https://api.openweathermap.org/data/2.5/forecast?{OWM_CITY_ID}&appid={OWM_API_KEY}&units={OWM_UNITS}\"\\n    try:\\n        resp = requests.get(url, timeout=10)\\n        resp.raise_for_status()\\n    except Exception as e:\\n        print(f\"Error fetching weather data: {e}\")\\n        return\\n    data = resp.json()\\n    global weather_data\\n    weather_data = []\\n    for item in data.get(\"list\", []):\\n        weather_data.append({\\n            \"dt\": item[\"dt\"],  # Unix timestamp\\n            \"dt_txt\": item[\"dt_txt\"],\\n            \"temp\": item[\"main\"][\"temp\"],\\n            \"weather\": item[\"weather\"][0][\"description\"],\\n        })\\n    # Persist to CSV for historical record\n    csv_file = Path(\"weather_history.csv\")\\n    with csv_file.open(\"a\", newline=\"\") as f:\\n        writer = csv.writer(f)\\n        if f.tell() == 0:  # write header on new file\\n            writer.writerow([\"timestamp\", \"temperature\", \"weather\"])\\n        for record in weather_data:\\n            writer.writerow([record[\"dt\"], record[\"temp\"], record[\"weather\"]])\\n\\n\\ndef format_forecast_summary():\\n    \"\"\"Return a plain text summary of the next 24 hours.\"\"\"\\n    now = datetime.datetime.utcnow()\\n    summary_lines = [\"Weather Forecast for Next 24 Hours:\"]\\n    for record in weather_data:\\n        dt = datetime.datetime.utcfromtimestamp(record[\"dt\"])\\n        if now <= dt <= now + datetime.timedelta(hours=24):\\n            time_str = dt.strftime(\"%H:%M\")\\n            summary_lines.append(f\"{time_str} - {record['temp']}°{OWM_UNITS[0].upper()}, {record['weather']}\")\\n    return \"\\n\".join(summary_lines)\\n\\n\\ndef send_email_alert():\\n    \"\"\"Send daily email with the weather summary.\"\"\"\\n    msg = MIMEText(format_forecast_summary())\\n    msg[\"Subject\"] = \"Morning Weather Update\"\\n    msg[\"From\"] = EMAIL_FROM\\n    msg[\"To\"] = EMAIL_TO\\n    try:\\n        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)\\n        server.starttls()\\n        server.login(SMTP_USER, SMTP_PASSWORD)\\n        server.send_message(msg)\\n        server.quit()\\n        print(\"Email sent successfully\")\\n    except Exception as e:\\n        print(f\"Error sending email: {e}\")\\n\\n\\ndef send_text_alert():\\n    \"\"\"Send SMS with the forecast summary via Twilio.\"\"\"\\n    try:\\n        client = TwilioClient(TWILIO_SID, TWILIO_TOKEN)\\n        message = client.messages.create(\\n            body=format_forecast_summary(),\\n            from_=TWILIO_FROM,\\n            to=TWILIO_TO,\\n        )\\n        print(f\"Text sent, SID: {message.sid}\")\\n    except Exception as e:\\n        print(f\"Error sending text: {e}\")\\n\\n\\ndef scheduled_daily_notification():\\n    \"\"\"Job to run daily at NOTIFY_HOUR to send notifications.\"\"\"\\n    print(\"Running daily notification job...\")\\n    fetch_weather_data()  # Ensure we have the latest data\\n    send_email_alert()\\n    send_text_alert()\\n\\n# ------------------- Dashboard Setup -------------------\\napp = Flask(__name__)\\n\\ndash_app = dash.Dash(__name__, server=app, routes_pathname_prefix=\"/dash/\")\\n\\ndef build_dash_layout():\\n    return html.Div([\\n        html.H1(\"Weather Dashboard\"),\\n        dcc.Graph(id=\"temp-graph\"),\\n        dcc.Interval(id=\"interval-component\", interval=10 * 60 * 1000, n_intervals=0),  # Update every 10 min\\n        dcc.Markdown(id=\"stats-md\"),\\n    ])\\n\\n@dash_app.callback(\\n    [dash.dependencies.Output(\"temp-graph\", \"figure\"),\\n     dash.dependencies.Output(\"stats-md\", \"children\")],\\n    [dash.dependencies.Input(\"interval-component\", \"n_intervals\")],\\n)\\ndef update_dashboard(n):\\n    # Prepare figure\n    times = [datetime.datetime.utcfromtimestamp(rec[\"dt\"]) for rec in weather_data]\\n    temps = [rec[\"temp\"] for rec in weather_data]\\n    fig = go.Figure(data=[go.Scatter(x=times, y=temps, mode=\"lines+markers\")])\\n    fig.update_layout(title=\"Temperature Forecast\", xaxis_title=\"Time\", yaxis_title=f\"Temperature ({OWM_UNITS})\")\\n    # Stats card\n    today_avg = sum(temps) / len(temps) if temps else 0\\n    stats = f\"**Average Temp:** {today_avg:.1f}°{OWM_UNITS[0].upper()}\"\\n    return fig, stats\\n\\ndash_app.layout = build_dash_layout()\\n\\n# ------------------- Scheduler Setup -------------------\\nscheduler = BackgroundScheduler(timezone=TIMEZONE)\\n# Hourly weather fetch\nscheduler.add_job(fetch_weather_data, trigger=\"interval\", minutes=60, next_run_time=datetime.datetime.now())\\n# Daily notification at specific hour\nnext = datetime.datetime.now(pytz.timezone(TIMEZONE))\\nnext = next.replace(hour=NOTIFY_HOUR, minute=0, second=0, microsecond=0)\\nif datetime.datetime.now(pytz.timezone(TIMEZONE)) > next:\\n    next += datetime.timedelta(days=1)\\nscheduler.add_job(scheduled_daily_notification, trigger=\"date\", run_date=next)\\nscheduler.add_job(scheduled_daily_notification, trigger=\"cron\", hour=NOTIFY_HOUR, minute=0)\\n\\n# ------------------- Main -------------------\\nif __name__ == \"__main__\":\\n    fetch_weather_data()  # Initial load\\n    scheduler.start()\\n    print(\"Starting web server at\", MIRROR_URL)\\n    app.run(host=\"0.0.0.0\", port=8050)\\n",
    "status": "success",
    "executed_at": "2025-11-06T13:42:07.681251Z",
    "source": "https://www.reddit.com/r/learnpython/comments/13l1ru4/suggest_me_some_ideas_of_automation_project_in/"
  },
  {
    "id": 1762435254,
    "title": "9 Python Project Ideas That Instantly Level Up Your Portfolio",
    "summary": "A command‑line utility that scans a specified folder, determines file types by extension, and moves each file into a dedicated subfolder (e.g., Images, Documents, Scripts). If a file’s type isn’t listed it goes into an Others folder. The script is portable, uses pathlib for path handling, and includes basic argument parsing.",
    "details_markdown": "import os\nimport shutil\nfrom pathlib import Path\n\ndef sort_directory(source_dir, target_root=None, extensions_map=None):\n    \"\"\"\n    Scan source_dir, sort files into subfolders in target_root.\n    \"\"\"\n    source_dir = Path(source_dir).expanduser().resolve()\n    target_root = Path(target_root or source_dir).expanduser().resolve()\n    if extensions_map is None:\n        extensions_map = {\n            \"Images\": [\"png\", \"jpg\", \"jpeg\", \"gif\"],\n            \"Documents\": [\"pdf\", \"docx\", \"txt\"],\n            \"Archives\": [\"zip\", \"tar\", \"gz\"],\n            \"Scripts\": [\"py\", \"js\", \"sh\"],\n            \"Others\": []\n        }\n    ext_to_folder = {}\n    for folder, exts in extensions_map.items():\n        for ext in exts:\n            ext_to_folder[ext.lower()] = folder\n    for item in source_dir.iterdir():\n        if item.is_file():\n            ext = item.suffix.lower().lstrip('.')\n            folder_name = ext_to_folder.get(ext, \"Others\")\n            target_dir = target_root / folder_name\n            target_dir.mkdir(parents=True, exist_ok=True)\n            shutil.move(str(item), str(target_dir / item.name))\n\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Smart File Sorter\")\n    parser.add_argument(\"source\", help=\"Source directory to sort\")\n    parser.add_argument(\"-t\", \"--target\", help=\"Target root directory (default: source)\")\n    args = parser.parse_args()\n    sort_directory(args.source, args.target)\n    print(\"Sorting completed.\")",
    "status": "success",
    "executed_at": "2025-11-06T13:20:54.033698Z",
    "source": "https://python.plainenglish.io/9-python-project-ideas-that-instantly-level-up-your-portfolio-c1b83126bfc1?source=rss----78073def27b8---4"
  }
]